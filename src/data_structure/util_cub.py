import cupy as cp


def save_basic(file_path, array):
    """
    Saves a 3D CuPy ndarray as a .cub file.

    Parameters:
    file_path (str): Path to the .cub file.
    array (cp.ndarray): 3D CuPy array to save.
    """
    if array.ndim != 3:
        raise ValueError("Array must be 3D.")

    # Get the shape of the array
    shape = array.shape

    # Save the shape and data_structure to the file
    with open(file_path, 'wb') as f:
        # Save shape first (3 integers)
        f.write(cp.array(shape, dtype=cp.int32).tobytes())

        # Save the flattened array data_structure
        f.write(array.astype(cp.float32).tobytes())

def save_cub(file_path, array, voxel_size=(1.0, 1.0, 1.0)):
    """
    Saves a 3D CuPy ndarray as a .cub file with a single hydrogen atom at the center.

    Parameters:
    file_path (str): Path to the .cub file.
    array (cp.ndarray): 3D CuPy array to save.
    voxel_size (tuple): Voxel size along each axis (dx, dy, dz).
    """
    if array.ndim != 3:
        raise ValueError("Array must be 3D.")

    nx, ny, nz = array.shape
    dx, dy, dz = voxel_size

    # Calculate origin to center the grid at (0, 0, 0)
    origin_x = - (nx * dx) / 2.0
    origin_y = - (ny * dy) / 2.0
    origin_z = - (nz * dz) / 2.0

    with open(file_path, 'w') as f:
        # First two comment lines
        f.write("Generated by save_cub\n")
        f.write("OUTER LOOP: X, MIDDLE LOOP: Y, INNER LOOP: Z\n")

        # Third line: number of atoms and origin of volumetric data_structure
        f.write(f"{1:5d} {origin_x:12.6f} {origin_y:12.6f} {origin_z:12.6f}\n")

        # Next three lines: number of voxels and voxel vectors
        f.write(f"{nx:5d} {dx:12.6f} {0.0:12.6f} {0.0:12.6f}\n")
        f.write(f"{ny:5d} {0.0:12.6f} {dy:12.6f} {0.0:12.6f}\n")
        f.write(f"{nz:5d} {0.0:12.6f} {0.0:12.6f} {dz:12.6f}\n")

        # Atom information: Single hydrogen atom at the center
        # Atomic number for hydrogen is 1
        # Charge is 0.0 (assuming neutral atom)
        f.write(f"{1:5d} {0.0:12.6f} {0.0:12.6f} {0.0:12.6f} {0.0:12.6f}\n")

        # Retrieve data_structure from GPU to CPU
        data = array.get()

        # Volumetric data_structure: write one floating point number per voxel
        # Outer loop: X, Middle loop: Y, Inner loop: Z
        count = 0
        for ix in range(nx):
            for iy in range(ny):
                for iz in range(nz):
                    value = data[ix, iy, iz]
                    f.write(f"{value:13.5E}")
                    count += 1
                    if count % 6 == 0:
                        f.write("\n")
                # Ensure a newline after each Z-axis loop if needed
                if count % 6 != 0:
                    f.write("\n")
        # Add a final newline at the end of the file
        f.write("\n")


def load_basic(file_path):
    """
    Loads a .cub file into a 3D CuPy ndarray.

    Parameters:
    file_path (str): Path to the .cub file.

    Returns:
    cp.ndarray: The loaded 3D CuPy array.
    """
    with open(file_path, 'rb') as f:
        # Read the shape (3 integers)
        shape = cp.frombuffer(f.read(12), dtype=cp.int32)
        shape = tuple(shape.get())
        # Read the flattened array data_structure
        array = cp.frombuffer(f.read(), dtype=cp.float32)

        # Reshape it into the original 3D shape
        array = array.reshape(shape)

    return array
